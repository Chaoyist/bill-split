/**
 * LINE Group Split Bill Backend v3.0 (Edit & Delete Support)
 * Features: CRUD for Expenses
 */

const CHANNEL_ACCESS_TOKEN = PropertiesService.getScriptProperties().getProperty('CHANNEL_ACCESS_TOKEN'); 
const LIFF_ID = '2009031450-O3r9jaRJ'; 

const DB_SCHEMA = {
  'Projects': ['id', 'name', 'ownerId', 'status', 'boundGroupId', 'timestamp'],
  'Users': ['userId', 'displayName', 'pictureUrl', 'lastSeenGroupId', 'timestamp'],
  'ProjectMembers': ['projectId', 'userId', 'joinedAt'],
  'Expenses': ['projectId', 'id', 'payerId', 'amount', 'item', 'splitMembers', 'timestamp']
};

function setupDatabase() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  Object.keys(DB_SCHEMA).forEach(sheetName => {
    ensureSheet(ss, sheetName);
  });
}

function ssGetSheet(name) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  return ensureSheet(ss, name);
}

function ensureSheet(ss, name) {
  let sheet = ss.getSheetByName(name);
  if (!sheet) {
    if (DB_SCHEMA[name]) {
      sheet = ss.insertSheet(name);
      sheet.appendRow(DB_SCHEMA[name]);
      sheet.setFrozenRows(1);
    } else {
      throw new Error(`Critical Error: Sheet "${name}" is not defined in schema.`);
    }
  }
  return sheet;
}

function doPost(e) {
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
  } catch (e) {
    return createJsonResponse({ status: 'error', message: 'Server busy' });
  }

  try {
    const postData = JSON.parse(e.postData.contents);

    if (postData.events) {
      handleLineWebhook(postData.events);
      return ContentService.createTextOutput(JSON.stringify({status: 'ok'})).setMimeType(ContentService.MimeType.JSON);
    } else if (postData.action) {
      const result = handleClientApi(postData);
      return createJsonResponse(result);
    } else {
      return createJsonResponse({ status: 'error', message: 'Invalid Request' });
    }
  } catch (err) {
    console.error('API Error: ' + err.toString()); 
    return createJsonResponse({ status: 'error', message: err.toString() });
  } finally {
    lock.releaseLock();
  }
}

function createJsonResponse(data) {
  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

// --- LINE Webhook ---

function handleLineWebhook(events) {
  events.forEach(event => {
    if (event.type === 'message' && event.message.type === 'text') {
      const text = event.message.text.trim();
      const hasMention = event.message.mention && event.message.mention.mentions && event.message.mention.mentions.length > 0;
      const groupId = event.source.groupId || event.source.roomId;

      if (!groupId) return;

      if (text.includes('分帳') || text.includes('記帳') || text.includes('分錢') || hasMention) {
        replyLiffMessage(event.replyToken, groupId);
      }
    }
  });
}

function replyLiffMessage(replyToken, groupId) {
  if (!CHANNEL_ACCESS_TOKEN) return;
  const liffUrl = `https://liff.line.me/${LIFF_ID}?groupId=${groupId}`;

  const payload = {
    replyToken: replyToken,
    messages: [{
      type: "flex",
      altText: "開啟分帳小幫手",
      contents: {
        type: "bubble",
        body: {
          type: "box",
          layout: "vertical",
          contents: [
            { type: "text", text: "分帳小幫手", weight: "bold", size: "xl", color: "#1DB446" },
            { type: "text", text: "點擊下方按鈕開始管理帳務", size: "sm", color: "#aaaaaa", margin: "md" }
          ]
        },
        footer: {
          type: "box",
          layout: "vertical",
          contents: [
            { type: "button", style: "primary", color: "#1DB446", action: { type: "uri", label: "開啟帳本", uri: liffUrl } }
          ]
        }
      }
    }]
  };

  try {
    UrlFetchApp.fetch('https://api.line.me/v2/bot/message/reply', {
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + CHANNEL_ACCESS_TOKEN },
      method: 'post',
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    });
  } catch (e) {
    console.error('Line Reply Exception: ' + e.toString());
  }
}

// --- Client API ---

function handleClientApi(data) {
  switch (data.action) {
    case 'syncUser': return syncUser(data.payload);
    case 'getProjects': return getProjects(data.payload.groupId);
    case 'createProject': return createProject(data.payload);
    case 'joinProject': return joinProject(data.payload);
    case 'getProjectDetails': return getProjectDetails(data.payload.projectId);
    case 'addExpense': return addExpense(data.payload);
    case 'updateExpense': return updateExpense(data.payload); // New
    case 'deleteExpense': return deleteExpense(data.payload); // New
    case 'settle': return calculateSettlement(data.payload.projectId);
    default: return { status: 'error', message: 'Unknown action' };
  }
}

// ... syncUser, getProjects, createProject, joinProject, getProjectDetails ...
// (These remain mostly same, simplified here for brevity, ensuring complete context in file)

function syncUser(payload) {
  const sheet = ssGetSheet('Users');
  const { userId, displayName, pictureUrl, groupId } = payload;
  const data = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === userId) { rowIndex = i + 1; break; }
  }
  const timestamp = new Date();
  const gidStr = String(groupId);
  if (rowIndex > 0) {
    sheet.getRange(rowIndex, 2, 1, 4).setValues([[displayName, pictureUrl, gidStr, timestamp]]);
  } else {
    sheet.appendRow([userId, displayName, pictureUrl, gidStr, timestamp]);
  }
  return { status: 'success' };
}

function getProjects(groupId) {
  const sheet = ssGetSheet('Projects');
  const rows = sheet.getDataRange().getValues().slice(1);
  const targetGid = String(groupId);
  const projects = rows
    .filter(r => String(r[4]) === targetGid && r[3] !== 'archived')
    .map(r => ({ id: r[0], name: r[1], ownerId: r[2], status: r[3], timestamp: r[5] }));
  projects.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  return { status: 'success', projects: projects };
}

function createProject(payload) {
  const pSheet = ssGetSheet('Projects');
  const mSheet = ssGetSheet('ProjectMembers');
  const { name, ownerId, boundGroupId } = payload;
  const id = Utilities.getUuid();
  const timestamp = new Date();
  pSheet.appendRow([id, name, ownerId, 'active', String(boundGroupId), timestamp]);
  mSheet.appendRow([id, ownerId, timestamp]);
  return { status: 'success', projectId: id };
}

function joinProject(payload) {
  const sheet = ssGetSheet('ProjectMembers');
  const { projectId, userId } = payload;
  const rows = sheet.getDataRange().getValues();
  const exists = rows.some(r => r[0] === projectId && r[1] === userId);
  if (!exists) sheet.appendRow([projectId, userId, new Date()]);
  return { status: 'success' };
}

function getProjectDetails(projectId) {
  const expSheet = ssGetSheet('Expenses');
  const memSheet = ssGetSheet('ProjectMembers');
  const userSheet = ssGetSheet('Users');
  
  const expRows = expSheet.getDataRange().getValues().slice(1);
  const projectExpenses = expRows
    .filter(r => r[0] === projectId)
    .map(r => ({ 
      id: r[1], 
      payerId: r[2], 
      amount: r[3], 
      item: r[4], 
      splitMembers: safeParse(r[5]), // Include splitMembers
      timestamp: r[6] 
    })).reverse();

  const memRows = memSheet.getDataRange().getValues().slice(1);
  const memberIds = memRows.filter(r => r[0] === projectId).map(r => r[1]); 
  
  const userRows = userSheet.getDataRange().getValues().slice(1);
  const userMap = {};
  userRows.forEach(r => {
    const uid = r[0];
    if (memberIds.includes(uid) || r[0]) { // Simplified user fetch
        userMap[uid] = { userId: uid, displayName: r[1], pictureUrl: r[2] };
    }
  });
  
  return { status: 'success', expenses: projectExpenses, users: userMap, memberIds: memberIds };
}

function safeParse(jsonStr) {
  try { return JSON.parse(jsonStr); } catch(e) { return []; }
}

function addExpense(payload) {
  const sheet = ssGetSheet('Expenses');
  const { projectId, payerId, amount, item, splitMembers } = payload;
  const id = Utilities.getUuid();
  // ['projectId', 'id', 'payerId', 'amount', 'item', 'splitMembers', 'timestamp']
  sheet.appendRow([projectId, id, payerId, amount, item, JSON.stringify(splitMembers), new Date()]);
  return { status: 'success', id: id };
}

// --- NEW CRUD ---

function updateExpense(payload) {
  const sheet = ssGetSheet('Expenses');
  const { id, payerId, amount, item, splitMembers } = payload;
  const data = sheet.getDataRange().getValues();
  
  // Find Row by Expense ID (Column B -> index 1)
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === id) {
      // Update columns C, D, E, F (payer, amount, item, split)
      // Indexes: 2, 3, 4, 5
      const rowIndex = i + 1;
      sheet.getRange(rowIndex, 3, 1, 4).setValues([[payerId, amount, item, JSON.stringify(splitMembers)]]);
      return { status: 'success' };
    }
  }
  return { status: 'error', message: 'Expense not found' };
}

function deleteExpense(payload) {
  const sheet = ssGetSheet('Expenses');
  const { id } = payload;
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][1] === id) {
      sheet.deleteRow(i + 1);
      return { status: 'success' };
    }
  }
  return { status: 'error', message: 'Expense not found' };
}

function calculateSettlement(projectId) {
  const expSheet = ssGetSheet('Expenses');
  const rows = expSheet.getDataRange().getValues().slice(1);
  const projectExpenses = rows.filter(r => r[0] === projectId);
  
  let balances = {}; 
  projectExpenses.forEach(row => {
    const payerId = row[2];
    const amount = parseFloat(row[3]);
    const splitMembers = safeParse(row[5]);
    
    if (!splitMembers.length) return;
    const splitAmount = amount / splitMembers.length;
    balances[payerId] = (balances[payerId] || 0) + amount;
    splitMembers.forEach(uid => { balances[uid] = (balances[uid] || 0) - splitAmount; });
  });
  
  let debtors = []; let creditors = [];
  for (const [uid, amount] of Object.entries(balances)) {
    const rounded = Math.round(amount * 100) / 100;
    if (rounded < -0.01) debtors.push({ userId: uid, amount: rounded });
    if (rounded > 0.01) creditors.push({ userId: uid, amount: rounded });
  }
  
  debtors.sort((a, b) => a.amount - b.amount);
  creditors.sort((a, b) => b.amount - a.amount);
  
  let transactions = []; let i = 0, j = 0;
  while (i < debtors.length && j < creditors.length) {
    let debtor = debtors[i]; let creditor = creditors[j];
    let amount = Math.min(Math.abs(debtor.amount), creditor.amount);
    transactions.push({ from: debtor.userId, to: creditor.userId, amount: Math.round(amount * 100) / 100 });
    debtor.amount += amount; creditor.amount -= amount;
    if (Math.abs(debtor.amount) < 0.01) i++;
    if (creditor.amount < 0.01) j++;
  }
  return { status: 'success', transactions: transactions };
}
